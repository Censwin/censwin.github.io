---
title: 006 重排及重绘
date: 2021-5-21
categories: 
 - 浏览器
tags:
 - 浏览器
sidebar: 'auto'
---

有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——“重排”“重绘”和“合成”。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。
## 重排
  **更新了元素的几何属性（重排）**
   <img :src="$withBase('/brower/redraw.png')">

   从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性（如宽、高、边距），例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫**重排**。无疑，**重排需要更新完整的渲染流水线，所以开销也是最大的。**
## 重绘
  ** 更新元素的绘制属性（重绘）**

   接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色（元素的颜色、背景色、边框等），渲染流水线会怎样调整呢？你可以参考下图：
   <img :src="$withBase('/brower/redraw2.png')">

   从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫 **重绘**。相较于重排操作，**重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。**
## 合成
  ** 直接合成阶段 **

   那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？ 直接进入合成阶段（例如CSS 的 transform 动画）,渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做 **合成**。具体流程参考下图：
   <img :src="$withBase('/brower/redraw3.png')">

   在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以**相对于重绘和重排，合成能大大提升绘制效率**。至于如何用这些概念去优化页面，我们会在后面相关章节做详细讲解的，这里你只需要先结合“渲染流水线”弄明白这三个概念及原理就行。

##  问题
有那些具体的实践方法能减少重绘、重排呢？
1. 使用 class 操作样式，而不是频繁操作 style
2. 避免使用 table 布局
3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
4. Debounce window resize 事件
5. 对 dom 属性的读写要分离
6. will-change: transform 做优化