---
title: 002 Generator 函数
date: 2021-7-18
categories: 
 - js
tags:
 - js
sidebar: 'auto'
---

> 对js来说异步编程是非常重要的，而es6的新概念比较抽象让我很费解，但这些新概念都是为了让异步编程更像同步编程。或者说比promise写法更接近于同步代码。

## 写法

```js
function* gen(x){
  var y = yield x + 2;
  return y;
}
```
生成器函数最大的特点就是交出控制权，此处的 yield 意思是**暂停**并将**执行权转移到协程B** 

```js
var g = gen(1);
g.next() // { value: 3, done: false } // next方法将执行权转交给协程A
g.next() // { value: undefined, done: true }
```

在上面代码中，一旦调用生成器函数，会返回一个指针而不是返回结果，对象中有 **value** 属性和 **done** 属性， <u>value 是 yield语句后面表达式的值，也可以说是这个阶段的值</u> ， done属性是一个布尔值，表示是否到底了，还有没有下一阶段了。

### 协程间的数据交换

next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。还可以获取 Generator 函数体外抛出的错误。

```js
function* gen(x){
  var y = yield x + 2;
  return y;
}
var g = gen(1);
g.next(2) // { value: 4, done: false }
g.next(99) // { value: 99, done: true }
```

抛错：

```js
function* gen(x){
  try {
    var y = yield x + 2;
  } catch (e){ 
    console.log(e);
  }
  return y;
}
var g = gen(1);
g.next();
g.throw（'出错了'）;
```

用法:

```js
function* deploy(arr){
    var Index = 0
    while(Index < arr.length){
        yield arr[Index++]
    }
}

var arr = ['name', 'age', 'sex', 'hobby']

var val = deploy(arr)
console.log(val.next())  // {value: "name", done: false}
console.log(val.next())  // {value: "age", done: false}
console.log(val.next())  // {value: "sex", done: false}
console.log(val.next())  // {value: "hobby", done: false}
console.log(val.next())  // {value: undefined, done: true}

for(let k of deploy(arr)) {
	console.log(k)  // name age sex hobby
}
```

此时我们还可以编写一个自动执行函数，让generator函数自动执行。dva.js 中看不到next其实就是做了封装

一个基于 Promise 对象的简单自动执行器：

```js
function run(gen){
  var g = gen();

  function next(data){
    var result = g.next(data);
    if (result.done) return result.value;
    result.value.then(function(data){
      next(data);
    });
  }

  next();
}
```

使用

```js
function* foo() {
    let response1 = yield fetch('https://xxx') //返回promise对象
    console.log('response1')
    console.log(response1)
    let response2 = yield fetch('https://xxx') //返回promise对象
    console.log('response2')
    console.log(response2)
}
run(foo);
```

上面代码中，只要 Generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。

