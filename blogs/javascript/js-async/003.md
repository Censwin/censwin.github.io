---
title: 003 thunk 是什么鬼
date: 2021-7-19
categories: 
 - js
tags:
 - js
sidebar: 'auto'
---

## JS中的thunk函数

我们先来看一个 thunk 实现 ajax 的例子

```js
const foo = function (res) {
    alert(res)
}
const getData = ajaxThunk('/api/test1')
getData(foo) // getData 接收一个回调函数为参数
// 或者
ajaxThunk('/api/test1')(foo)

const ajaxThunk = function (url) {
    return function (callback) {
        return request(url, callback)
    }
}

function request(url, cb) {
    $.ajax({
        url: url,
        success: cb
    });
}
```

这时候就有小伙伴要说了，这不是 `currying` 吗？怎么能叫 `thunk`？区别在于解决的问题不同，首先 两者都是符合函数式编程理念的，但 `thunk` 是用来做延迟计算，他将多参数改为单参数版本，且**只接收回调函数**，或在最后一个参数必传回调函数，而 `currying` 却无该限制。`thunk` 更多是想把执行函数和回调函数拆分开，让开发者在写异步代码的时候可以更专注于执行函数的逻辑。

[What is the difference between Thunk and currying in JavaScript?](https://stackoverflow.com/questions/61889157/what-is-the-difference-between-thunk-and-currying-in-javascript?noredirect=1&lq=1)

[Are thunk and function currying the same?](https://stackoverflow.com/questions/61584833/are-thunk-and-function-currying-the-same)

## Thunkify 模块

建议使用更完善的 thunkify 转换器生成 thunk 函数 [Thunkify 模块](https://github.com/tj/node-thunkify)

使用方法

```js
const reqThunk = thunkify(request);
reqThunk('/api/test1')(foo)
```

源码

```js
function thunkify(fn) {
    return function () {
        var args = new Array(arguments.length);
        var ctx = this;

        for (var i = 0; i < args.length; ++i) {
            args[i] = arguments[i];
        }

        return function (done) {
            var called;

            args.push(function () {
                if (called) return;
                called = true;
                done.apply(null, arguments);
            });

            try {
                fn.apply(ctx, args);
            } catch (err) {
                done(err);
            }
        }
    }
};
```

## 自定义逻辑怎么办

以`NodeJS`的核心模块`File System`的异步函数[readFile](https://link.jianshu.com/?t=https://nodejs.org/api/fs.html#fs_fs_readfile_file_options_callback)为例：

```js
// --------------thunk写法--------------
var readFile = thunkify(fs.readFile);
// 执行函数
var f1 = readFile('./a.js');
var f2 = readFile('./b.js');
var f3 = readFile('./c.js');
// 回调函数
f1(function(err, data1) {
	f2(function(err, data2) {
		f3(function (err, data3) {
		})
	})
})
// --------------thunk写法--------------


// ---------------传统写法-----------------
fs.readFile('./a.js', function(err, data1) {
	//传统定义的逻辑一般写在回调里， ajax也一样
	fs.readFile('./b.js', function(err, data2) {
		fs.readFile('./c.js', function(err, data3) {
		})
	})
})
// ---------------传统写法-----------------
```

根据 `thunk` 的理念我们将`执行函数`和`回调函数`分开以后,代码清晰了许多。 但是问题来了 **自定义的逻辑** 应该放在哪？

如果自定义的逻辑是放在`回调函数`集合那边，有两个缺点

1. 代码逻辑里面上面来说不符合常规逻辑
2. 回调函数里面嵌套逻辑处理太多的话，那thunk的优势就没了，且可读性大大降低

那就确定了把自定义的逻辑放在执行函数的一端，回调函数只是负责获取数据，并在数据传回执行函数集合

所以现在的基本流程就是

```python
执行函数执行-->等待回调函数传回数据-->用户对于获取的数据进行操作
```

等待传回数据不就是 Gennerator 函数，Thunk函数确实没什么卵用，真正让其发挥作用的是配合Generator函数实现自动化异步操作

## 如何结合？

把所有的执行函数放入`generator`函数里面,利用`generator`函数的`yield`对执行函数的流程控制 把函数执行权移出函数到对应的回调函数，获取数据后再把数据返回来

利用`fs.readFile`举例子

利用`thunk`把`fs.readFile(arguments, callback)`  执行的参数和回调函数分开 从而变成 执行函数放在一起  回调函数放在一起 利用`yield`进行连接

```js
var fs = require('fs');
var readFile = thunkify(fs.readFile);

//发现执行参数的函数在一起
var gen = function* () {
	var data1 = yield readFile('./a.js');
	//用户获取数据后自定义写在这里
	console.log(data1.toString());
	var data2 = yield readFile('./b.js');
		//用户获取数据后自定义写在这里
	console.log(data2);
}
//写个执行函数
//发现callback在一起  而且调用的形式都一样
var g = gen();
var d1 = g.next();

//执行value 实际为执行总函数 -->回调函数
d1.value(function(err, data) {
	if (err) throw err;
	//传回数据
	var d2 = g.next(data);
	d2.value(function(err, data2) {
		if (err) throw err;
		g.next(data2);
	});
});
```

该函数形式单一，基本形式为

```javascript
d.value(function(err, data) {
 	if (err) throw err;
 	g.next(data);
 })
```

可以利用递归写一个 **Thunk自动执行器**

```javascript
function run(fn) {
	var g = fn();
	//下一步----实际就是回调函数
	function next(err, data) {
		//把前面一个数据给传递到gen()函数里面
		var result = g.next(data);
		//判断是否结束
		if (result.done) return;
		//下一句执行回调next的时候 不断的递归
		result.value(next);
	}
	//执行第一步
	next();
}
run(gen);
```

定义了run方法后，执行`Generator`函数就方便到令人发指。直接将`Generator`函数作为参数传给run就行了。然后会自动像多米诺骨牌一样依次执行`Generator`函数内的异步操作。当然，前提是每一个异步操作，都要是`Thunk`函数，即`yield`命令后面的必须是`Thunk`函数。

`Thunk`函数是自动执行`Generator`函数的一种选择，如果不习惯，或者觉得用`Thunk`函数并不会提高效率的话，可以像`Generator`一文中那样定义run，同样可以使`Generator`函数自动执行。

---

参考： [朱桂彪](https://blog.csdn.net/m0_37036014/article/details/102697130) 、 [yongningfu](https://cnodejs.org/topic/57c95bb86f7069ce262d0531) 、 [维基百科](https://zh.wikipedia.org/wiki/求值策略) 、 [阮一峰](https://www.ruanyifeng.com/blog/2015/05/thunk.html)

