---
title: 001 生命周期
date: 2021-9-15
categories: 
 - React
tags:
 - React
sidebar: 'auto'
---

 众所周知react16.3及以上版本中废除了原有的`componentWillMount()`、`componentWillUpdate()`以及`componentWillReceiveProps()`三个生命周期函数。取而代之的是`static getDerivedStateFromProps()`以及`getSnapshotBeforeUpdate()`。

被废除的三个生命周期函数均出现在render之前

##  componentWillMount

1. willMount中请求数据以优化白屏

   在此生命周期进行请求数据来解决首页白屏问题，但是并没有解决掉，由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。当React渲染一个组件时，它不会等待`componentWillMount`它完成任何事情 - React继续前进并继续`render`,没有办法“暂停”渲染以等待数据到达。

   你可能会误以为`componentWillMount`在 render 之前执行，早一点执行就早拿到请求结果；但是其实不管你请求多快，都赶不上首次 render，页面首次渲染依旧处于没有获取异步数据的状态。

2. 服务端渲染重复执行

   `componentWillMount`是服务端渲染唯一会调用的生命周期函数，如果你在此方法中请求数据，那么服务端渲染的时候，在服务端和客户端都会分别请求两次相同的数据

   特别是有了 React Fiber，更有机会被调用多次，故请求不应该放在`componentWillMount`中，完全可由conductor或componentDidMount替代

3. 利用componentWillMount以及componentWillUnmount对称性来进行订阅取消事件

   在`componentWillMount`中订阅事件，并在`componentWillUnmount`中取消掉相应的事件订阅。事实上只有调用`componentDidMount`后，React 才能保证稍后调用`componentWillUnmount`进行清理。而且服务端渲染时不会调用`componentWillUnmount`，可能导致内存泄露

## componentWillReceiveProps

官方说法是 无论props是否修改，只要父组件render就会执行该函数。

还有一点是如果组件自身的某个 state 跟父组件传入的 props 密切相关的话，那么可以在该方法中判断前后两个 props 是否相同，如果不同就根据 props 来更新组件自身的 state。

类似的业务需求比如：一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的状态，但很多情况下，业务需求会要求从外部跳转至列表时，根据传入的某个值，直接定位到某个 Tab。

该方法缺点是会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。

新生命周期方法`static getDerivedStateFromProps(props, state)`怎么用呢？

> getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。

从函数名字就可以看出大概意思：使用 props 来派生/更新 state。这就是重点了，但凡你想使用该函数，都必须出于该目的，使用它才是正确且符合规范的。

跟`getDerivedStateFromProps`不同的是，它在挂载和更新阶段都会执行（`componentWillReceiveProps`挂载阶段不会执行），因为更新 state 这种需求不仅在 props 更新时存在，在 props 初始化时也是存在的。

而且`getDerivedStateFromProps`在组件自身 state 更新也会执行而`componentWillReceiveProps`方法执行则取决于父组件的是否触发重新渲染，也可以看出`getDerivedStateFromProps`并不是 `componentWillReceiveProps`方法的替代品.

引起我们注意的是，这个生命周期方法是一个静态方法，静态方法不依赖组件实例而存在，故在该方法内部是无法访问 this 的。新版本生命周期方法能做的事情反而更少了，限制我们只能根据 props 来派生 state，官方是基于什么考量呢？

因为无法拿到组件实例的 this，这也导致我们无法在函数内部做 this.fetch()请求，或者不合理的 this.setState()操作导致可能的死循环或其他副作用。有没有发现，这都是不合理不规范的操作，但开发者们都有机会这样用。可如果加了个静态 static，间接强制我们都无法做了，也从而避免对生命周期的滥用。

React 官方也是通过该限制，尽量保持生命周期行为的可控可预测，根源上帮助了我们避免不合理的编程方式，即一个 API 要保持单一性，做一件事的理念。

如下例子：

```js
// before
componentWillReceiveProps(nextProps) {
  if (nextProps.isLogin !== this.props.isLogin) {
    this.setState({
      isLogin: nextProps.isLogin,
    });
  }
  if (nextProps.isLogin) {
    this.handleClose();
  }
}

// after
static getDerivedStateFromProps(nextProps, prevState) {
  if (nextProps.isLogin !== prevState.isLogin) { // 被对比的props会被保存一份在state里
    return {
      isLogin: nextProps.isLogin, // getDerivedStateFromProps 的返回值会自动 setState
    };
  }
  return null;
}

componentDidUpdate(prevProps, prevState) {
  if (!prevState.isLogin && this.props.isLogin) {
    this.handleClose();
  }
}
```

## componentWillUpdate



---

参考文献：

[rfrc](https://github.com/reactjs/rfcs/blob/main/text/0006-static-lifecycle-methods.md)

https://blog.csdn.net/y523006369/article/details/103630145?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link

https://segmentfault.com/a/1190000021272657

https://juejin.cn/post/6844903782044663816

https://zhuanlan.zhihu.com/p/65124686

https://segmentfault.com/q/1010000008133309

https://jacky-summer.github.io/2020/11/30/%E8%B0%88%E8%B0%88%E5%AF%B9-React-%E6%96%B0%E6%97%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/