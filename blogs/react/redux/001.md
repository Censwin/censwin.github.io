---
title: 001 Redux 前世今生
date: 2021-11-1
categories: 
 - Redux
tags:
 - Redux
sidebar: 'auto'
---

## Flux

Flux 本身既不是库，也不是框架，而是一种应用的架构思想，由 Facebook 团队提出，用来替代饱受诟病的MVC架构，是单向数据流的鼻祖、redux的前身。

#### Flux 主要特点

1. Store 包含状态和更改逻辑 
2. 有多个 Store
3. 所有 Store 都互不影响且是平级的
4. 有单一调度器
5. React 组件订阅 store
6. 状态是可变的

#### Flux 主要有4部分组成

1. Action 

   顾名思义是一个动作指令, 如 {type: 'add'}，通过该对象通知 `Dispatcher` 做出对应修改

   > 对于action对象的定义还有一套规范称为 FSA（Flux Standard Action）该规范定义了一个 Flux action 必须拥有一个 `type` 字段，可以拥有 `error` 、`payload` 或 `meta` 字段。除此之外，不能有其他额外的字段。详见 https://github.com/acdlite/flux-standard-action 

2. Store

   Flux 中的 Store 类似于 model，用来 **存储数据**  并定义 **数据修改的逻辑** 

   如：

   ```jsx
   const store = Object.assign(EventEmitter.prototype, {
     items: [],
   
     emitChange() {
       this.emit('change');
     },
     addChangeListener(callback) {
       this.on('change', callback);
     },
     addItem(text) {
       this.items.push(text);
     },
   });
   ```

3. Dispatcher (核心)

   `Dispatcher` 通过接收 `Action` 处理动作分发并维持`store`之间的依赖关系， 可以说 `Dispatcher` 将 `action` 及 `store` 连接到了一起， 不同的 `action` 通过 `swich` 调取不同的数据修改逻辑

   ```jsx
   flux.register(function(action) {
     switch (action.type) {
       case 'add':
         const { text } = action.payload;
         store.addItem(text);
         break;
       default:
         break;
     }
     store.emitChange();
   });
   ```

   

4. View

   `View` 除了显示界面， 在修改界面时必须要发起一个`action`

5. 上图
 <img :src="$withBase('/react/redux001.png')" alt="foo">   

[简单案例-codesanbox](https://codesandbox.io/s/flux-example-kp01g)

####  Flux 的不足

1. 代码冗余与store依赖

    Flux 的冗余代码太多。虽然 Flux 源码中几乎只有 dispatcher 的现实，但是在每个应用中都需要手动创建一个 dispatcher 的示例，且如果两个Store之间有逻辑依赖关系，还必须用上Dispatcher的waitFor函数。虽然Flux这个设计的确解决了Store之间的依赖关系，但是，这样明显的模块之间的依赖，看着还是让人感觉不大舒服，毕竟，最好的依赖管理是根本不让依赖产生。说到底，Flux 给开发者提供的还是它的思想。

2. 难以进行服务器端渲染

   在Flux的体系中，有一个全局的Dispatcher，然后每一个Store都是一个全局唯一的对象，这对于浏览器端应用完全没有问题，但是如果放在服务器端，就会有大问题。

   和一个浏览器网页只服务于一个用户不同，在服务器端要同时接受很多用户的请求，如果每个Store都是全局唯一的对象，那不同请求的状态肯定就乱套了。

   并不是说Flux不能做服务器端渲染，只是说让Flux做服务器端渲染很困难，实际上，Facebook也说的很清楚，Flux不是设计用作服务器端渲染的，他们也从来没有尝试过把Flux应用于服务器端。

3. Store混杂了逻辑和状态

   Store封装了数据和处理数据的逻辑，用面向对象的思维来看，这是一件好事，毕竟对象就是这样定义的。但是，当我们需要动态替换一个Store的逻辑时，只能把这个Store整体替换掉，那也就无法保持Store中存储的状态

## Redux

我们都知道 Flux 本身既不是库，也不是框架，而是一种应用的架构思想。而 Redux 呢，它的核心代码可以理解成一个库，但同时也强调与 Flux 类似的架构思想。从设计上看，Redux 参考了 Flux 的设计，但是对 Flux 许多冗余的部分（如 dispatcher）做了简化，但与Flux 最大的不同在于 不再像Flux以Dispatcher为中心

#### Redux 的主要特点

1. 唯一数据源

   带有分层 reducer 的单一 Store且 只有一个Store

2. 状态是只读的

   这一点其实跟Flux的思想是一样的，只是在Flux案例中，我们可以直接修改状态，但在Redux中我们连store都没有，或者说不会想Flux 用代码去定义一个store

3. 状态修改均由Reducer纯函数完成

#### Redux 的4个主要部分

1. Action

   与Flux的action没有什么不同
   
2. Reducer

   Reducer是一个纯函数，也就是说函数返回的结果必须由参数state和action决定，返回一个新的state, 而且不产生任何副作用也不能修改state和action对象

   ```js
   (state,action) => {
       return {...state, [caption]: state[caption] + 1};
   }
   ```

3. Store

   Redux的核心是一个store，我们通过redux提供的createStore(reducers, initState)来创建store，从函数签名也可以看出我们必须要传入一个reducer， 第二个参数为可选初始化数据。

   ```js
   const data = {
     'First': 0,
     'second': 1
   }
   const store = createStore(reducer,data)
   export default store
   ```
   
   创建的store还包括4个方法
   
   1. getState() : 获取store中当前的状态
   2. dispatch(): 用于分发action
   3. subscribe(): 注册一个监听者，用于store变化时调用
   4. replaceReducer(): 更新当前store的reducer
   
4. View

   为了将我们的store与view连接起来，我们还需要引入react-redux, 这个库提供了Provider和connect 用于连接

   - 在最顶层使用Provider包裹组件并传入store

     ```jsx
     <Provider store={store}>
         <APP>TITLE</APP>
     </Provider>
     ```

   - 在需要使用store数据的组件使用connect进行连接

     ```jsx
     export default connect(mapStateToProps, mapDispatchToProps)(Singer)
     ```

     - mapStateToProps（state, ownProps）
       mapStateToProps是一个函数，用于建立组件跟 store 的 state 的映射关系，作为一个函数，它可以传入两个参数，结果一定要返回一个 object，传入mapStateToProps之后，会订阅store的状态改变，在每次 store 的 state 发生变化的时候，都会被调用ownProps代表组件本身的props，如果写了第二个参数ownProps，那么当prop发生变化的时候，mapStateToProps也会被调用。例如，当 props接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。
       mapStateToProps可以不传，如果不传，组件不会监听store的变化，也就是说Store的更新不会引起UI的更新

       ```jsx
       const mapStateToProps = (state: { title: string }) => {
         return {
           state
         };
       };

     - mapDispatchToProps
       mapDispatchToProps用于建立组件跟store.dispatch的映射关系,可以是一个object，也可以传入函数，如果mapDispatchToProps是一个函数，它可以传入dispatch,ownProps, 定义UI组件如何发出action，实际上就是要调用dispatch这个方法

       ```js
       function changeStore (value) {
           return { type: "test", payload: { title: value } }
       }
       const mapDispatchToProps = (dispatch: Dispatch<any>) => {
         return {
           test: (value) =>
             dispatch(changeStore(value))
         };
       };
       ```

       **由于react-redux 内置了 `bindActionCreator` 所以mapDispatchToProps可以简写**， 如上述代码可简写为

       ```js
       const mapDispatchToProps = {
       	test(value)
       }
       ```

       `mapDispatchToProps`如果是一个`object`，这个`object`所对应的`value`必须是`actionCreator`，这样`redux`里面会自动帮我们调用`bindActionCreator`。
 <img :src="$withBase('/react/redux002.png')" alt="foo"> 

   [简单案例](https://codesandbox.io/s/simple-redux-demo-sjfm1?file=/src/App.tsx)

   #### createStore 源码

   ```js
   let createStore = (reducer) => {
       let state;
       //获取状态对象
       //存放所有的监听函数
       let listeners = [];
       let getState = () => state;
       //提供一个方法供外部调用派发action
       let dispath = (action) => {
           //调用管理员reducer得到新的state
           state = reducer(state, action);
           //执行所有的监听函数
           listeners.forEach((l) => l())
       }
       //订阅状态变化事件，当状态改变发生之后执行监听函数
       let subscribe = (listener) => {
           listeners.push(listener);
       }
       dispath();
       return {
           getState,
           dispath,
           subscribe
       }
   }
   let combineReducers=(renducers)=>{
       //传入一个renducers管理组，返回的是一个renducer
       return function(state={},action={}){
           let newState={};
           for(var attr in renducers){
               newState[attr]=renducers[attr](state[attr],action)
   
           }
           return newState;
       }
   }
   export {createStore,combineReducers};
   ```

   

