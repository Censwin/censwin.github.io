(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{528:function(t,r,a){"use strict";a.r(r);var v=a(6),s=Object(v.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——“重排”“重绘”和“合成”。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。")]),t._v(" "),a("h2",{attrs:{id:"重排"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重排"}},[t._v("#")]),t._v(" 重排")]),t._v(" "),a("p",[a("strong",[t._v("更新了元素的几何属性（重排）")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/brower/redraw.png")}})]),t._v(" "),a("p",[t._v("从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性（如宽、高、边距），例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫"),a("strong",[t._v("重排")]),t._v("。无疑，"),a("strong",[t._v("重排需要更新完整的渲染流水线，所以开销也是最大的。")])]),t._v(" "),a("h2",{attrs:{id:"重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),a("p",[t._v("** 更新元素的绘制属性（重绘）**")]),t._v(" "),a("p",[t._v("接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色（元素的颜色、背景色、边框等），渲染流水线会怎样调整呢？你可以参考下图：\n"),a("img",{attrs:{src:t.$withBase("/brower/redraw2.png")}})]),t._v(" "),a("p",[t._v("从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫 "),a("strong",[t._v("重绘")]),t._v("。相较于重排操作，"),a("strong",[t._v("重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。")])]),t._v(" "),a("h2",{attrs:{id:"合成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成"}},[t._v("#")]),t._v(" 合成")]),t._v(" "),a("p",[t._v("** 直接合成阶段 **")]),t._v(" "),a("p",[t._v("那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？ 直接进入合成阶段（例如CSS 的 transform 动画）,渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做 "),a("strong",[t._v("合成")]),t._v("。具体流程参考下图：\n"),a("img",{attrs:{src:t.$withBase("/brower/redraw3.png")}})]),t._v(" "),a("p",[t._v("在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以"),a("strong",[t._v("相对于重绘和重排，合成能大大提升绘制效率")]),t._v("。至于如何用这些概念去优化页面，我们会在后面相关章节做详细讲解的，这里你只需要先结合“渲染流水线”弄明白这三个概念及原理就行。")]),t._v(" "),a("h2",{attrs:{id:"问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),a("p",[t._v("有那些具体的实践方法能减少重绘、重排呢？")]),t._v(" "),a("ol",[a("li",[t._v("使用 class 操作样式，而不是频繁操作 style")]),t._v(" "),a("li",[t._v("避免使用 table 布局")]),t._v(" "),a("li",[t._v("批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React")]),t._v(" "),a("li",[t._v("Debounce window resize 事件")]),t._v(" "),a("li",[t._v("对 dom 属性的读写要分离")]),t._v(" "),a("li",[t._v("will-change: transform 做优化")])])])}),[],!1,null,null,null);r.default=s.exports}}]);