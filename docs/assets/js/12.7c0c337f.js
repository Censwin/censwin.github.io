(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{524:function(t,v,_){"use strict";_.r(v);var a=_(6),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"ip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ip"}},[t._v("#")]),t._v(" IP")]),t._v(" "),_("p",[t._v("ip 就是主机地址，这串数字符合网络协议标准\n当一个数据包从主机A 发往主机B时， 上层会将数据包交给网络层；网络层将ip头附加到数据包上，在通过底层物理方式将数据包传输到主机B，主机B 网络层获取数据包并在网络层将数据包拆开交还给上层；")]),t._v(" "),_("h2",{attrs:{id:"udp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[t._v("#")]),t._v(" UDP")]),t._v(" "),_("p",[t._v("Q: 当主机B接收到数据包后如何知道将数据包交给谁？")]),t._v(" "),_("p",[t._v("这就需要UDP来告知主机了，UDP头中最重要的信息是"),_("strong",[t._v("端口号")]),t._v("。系统中每个访问网络的应用程序都会分配一个端口号。因此UDP通过端口号将数据包传输给指定的程序。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。")]),t._v(" "),_("p",[t._v("流程如下:")]),t._v(" "),_("p",[t._v("【主机A】数据包（上层） => 添加UDP头（传输层）  =>  添加IP头（网络层）=> 物理层  => 【主机B】\n"),_("img",{attrs:{src:t.$withBase("/brower/udp.png"),alt:"foo"}})]),t._v(" "),_("p",[t._v("注意： UDP没有重发机制，也就是说如果丢包了就只能丢弃当前包，虽然UDP不能保证数据可靠性但是速度非常快，常被用在对数据完整度没有较高要求的领域，如在线视频、在线游戏、直播等；")]),t._v(" "),_("p",[_("strong",[t._v("相比于TCP UDP存在以下问题：")])]),t._v(" "),_("ol",[_("li",[t._v("容易丢包")]),t._v(" "),_("li",[t._v("当传输大文件时，由于数据被拆成n个小数据包，而UDP并不知道怎么将这些数据包还原成原始文件；")])]),t._v(" "),_("h2",{attrs:{id:"tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[t._v("#")]),t._v(" TCP")]),t._v(" "),_("p",[t._v("TCP传输流程与UDP一致")]),t._v(" "),_("p",[t._v("和UDP一样，TCP头同样包含目的端口号和本地端口号，另外还多了一个序列号用于整合文件；")]),t._v(" "),_("p",[t._v("一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。")]),t._v(" "),_("ul",[_("li",[t._v("【建立】建立连接（三次握手）：即客户端和服务端总共发送3个数据包用于建立连接；")]),t._v(" "),_("li",[t._v("【传输】这个阶段不同于UDP的是接收端每接受一个数据包都需要告知发送端，如果长时间没有反馈则会触发【重发机制】；而后接收端根据数据包的TCP头里的序号进行重排，从而保证数据完整；")]),t._v(" "),_("li",[t._v("【断开】即四次挥手来保证双方都能断开连接；")])]),t._v(" "),_("p",[t._v("由此TCP牺牲了数据传输速度来保证了数据完整性，同时因为三次握手及接收反馈机制，数据包数量大大增加；")]),t._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),_("p",[t._v("HTTP协议属于应用层，TCP协议属于传输层，HTTP协议位于TCP协议的上层。")]),t._v(" "),_("h2",{attrs:{id:"问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("浏览器可以同时打开多个页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？")]),t._v(" "),_("p",[t._v("端口一样的，网络进程知道每个tcp链接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程。")])]),t._v(" "),_("li",[_("p",[t._v("TCP传送数据时 浏览器端就做渲染处理了么？如果前面数据包丢了 后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？")]),t._v(" "),_("p",[t._v("接收到http响应头中的content-type类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做DOM解析了！基于http不用担心数据包丢失的问题，因为丢包和重传都是在tcp层解决的。http能保证数据按照顺序接收的（也就是说，从tcp到http的数据就已经是完整的了，即便是实时渲染，如果发生丢包也得在重传后才能开始渲染）")])]),t._v(" "),_("li",[_("p",[t._v("http 和 websocket都是属于应用层的协议吗？")]),t._v(" "),_("p",[t._v("都是应用层协议，而且websocket名字取的比较有迷惑性，其实和socket完全不一样，可以把websocket看出是http的改造版本，增加了服务器向客户端主动发送消息的能力。")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);